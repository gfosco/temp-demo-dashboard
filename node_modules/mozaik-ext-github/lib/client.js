'use strict';

var request = require('superagent-bluebird-promise');
var _ = require('lodash');
var chalk = require('chalk');
var config = require('./config');

var previewAcceptHeader = 'application/vnd.github.spiderman-preview';

var client = function client(mozaik) {

    mozaik.loadApiConfig(config);

    var buildApiRequest = function buildApiRequest(path, params) {
        var url = config.get('github.baseUrl');
        var req = request.get('' + url + path);

        var paramsDebug = params ? ' ' + JSON.stringify(params) : '';
        mozaik.logger.info(chalk.yellow('[github] calling ' + url + path + paramsDebug));

        if (params) {
            req.query(params);
        }

        req.set('Accept', previewAcceptHeader);

        if (config.get('github.token') !== '') {
            req.set('Authorization', 'token ' + config.get('github.token'));
        }

        return req.promise();
    };

    var _repositoryCommits = function _repositoryCommits(params, buffer) {
        return buildApiRequest('/repos/' + params.repository + '/commits', params).then(function (res) {
            buffer.commits = buffer.commits.concat(res.body);

            if (res.headers.link && /&page=(\d+)> rel="next"/.test(res.headers.link) === true && buffer.commits.length < buffer.max) {
                buffer.page = Number(/&page=(\d+)> rel="next"/.exec(res.headers.link)[1]);

                return _repositoryCommits(params, buffer);
            } else {
                return buffer.commits;
            }
        });
    };

    var apiCalls = {
        organization: function organization(_ref) {
            var _organization = _ref.organization;

            return buildApiRequest('/orgs/' + _organization).then(function (res) {
                return res.body;
            });
        },
        user: function user(_ref2) {
            var _user = _ref2.user;

            return buildApiRequest('/users/' + _user).then(function (res) {
                return res.body;
            });
        },
        repository: function repository(_ref3) {
            var _repository = _ref3.repository;

            return buildApiRequest('/repos/' + _repository).then(function (res) {
                return res.body;
            });
        },
        pullRequests: function pullRequests(_ref4) {
            var repository = _ref4.repository;

            return buildApiRequest('/repos/' + repository + '/pulls').then(function (res) {
                return { pullRequests: res.body };
            });
        },
        repositoryParticipationStats: function repositoryParticipationStats(_ref5) {
            var repository = _ref5.repository;

            return buildApiRequest('/repos/' + repository + '/stats/participation').then(function (res) {
                return res.body;
            });
        },
        repositoryLanguages: function repositoryLanguages(_ref6) {
            var repository = _ref6.repository;

            return buildApiRequest('/repos/' + repository + '/languages').then(function (res) {
                return res.body;
            });
        },
        branches: function branches(params) {
            return buildApiRequest('/repos/' + params.repository + '/branches').then(function (res) {
                return Promise.all(res.body.map(function (branch) {
                    return apiCalls.branch(_.extend({ branch: branch.name }, params));
                }));
            }).then(function (branches) {
                return { branches: branches };
            });
        },
        branch: function branch(_ref7) {
            var repository = _ref7.repository,
                _branch = _ref7.branch;

            return buildApiRequest('/repos/' + repository + '/branches/' + _branch).then(function (res) {
                return res.body;
            });
        },
        repositoryContributorsStats: function repositoryContributorsStats(_ref8) {
            var repository = _ref8.repository;

            return buildApiRequest('/repos/' + repository + '/stats/contributors').then(function (res) {
                return { contributors: res.body };
            });
        },
        repoCommitActivity: function repoCommitActivity(_ref9) {
            var repository = _ref9.repository;

            return buildApiRequest('/repos/' + repository + '/stats/commit_activity').then(function (res) {
                return { buckets: res.body };
            });
        },
        repositoryCommits: function repositoryCommits(params) {
            return _repositoryCommits(params, {
                commits: [],
                page: 1,
                max: 1000
            }).then(function (commits) {
                return commits;
            });
        },
        issues: function issues(_ref10) {
            var repository = _ref10.repository;

            return buildApiRequest('/repos/' + repository + '/issues').then(function (res) {
                return res.body;
            });
        },
        issueLabelsAggregations: function issueLabelsAggregations(params) {
            params.labels.forEach(function (label) {
                label.count = 0;
            });

            return Promise.all(params.labels.map(function (label) {
                return buildApiRequest('/repos/' + params.repository + '/issues', {
                    labels: label.name,
                    state: 'open',
                    filter: 'all'
                }).then(function (res) {
                    console.log(res);

                    label.count = res.body.length;

                    return label;
                });
            }));
        },
        status: function status() {
            var url = 'https://status.github.com/api/last-message.json';
            var req = request.get(url);

            mozaik.logger.info(chalk.yellow('[github] calling ' + url));

            return req.promise().then(function (res) {
                return res.body;
            });
        },
        trafficViews: function trafficViews(_ref11) {
            var repository = _ref11.repository;

            return buildApiRequest('/repos/' + repository + '/traffic/views').then(function (res) {
                return res.body;
            });
        },
        trafficClones: function trafficClones(_ref12) {
            var repository = _ref12.repository;

            return buildApiRequest('/repos/' + repository + '/traffic/clones').then(function (res) {
                return res.body;
            });
        }
    };

    return apiCalls;
};

module.exports = client;