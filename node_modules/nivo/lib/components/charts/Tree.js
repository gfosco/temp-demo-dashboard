/*
 * This file is part of the nivo project.
 *
 * (c) RaphaÃ«l Benitte
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDimensions = require('react-dimensions');

var _reactDimensions2 = _interopRequireDefault(_reactDimensions);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _d = require('d3');

var _d2 = _interopRequireDefault(_d);

var _Nivo = require('../../Nivo');

var _Nivo2 = _interopRequireDefault(_Nivo);

var _PropTypes = require('../../PropTypes');

var _ColorUtils = require('../../ColorUtils');

var _labels = require('../../lib/charts/labels');

var _labels2 = _interopRequireDefault(_labels);

var _HierarchyUtils = require('../../HierarchyUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var horizontalDiagonal = _d2.default.svg.diagonal().projection(function (d) {
    return [d.y, d.x];
});
var verticalDiagonal = _d2.default.svg.diagonal().projection(function (d) {
    return [d.x, d.y];
});

var horizontalTransform = function horizontalTransform(d) {
    return 'translate(' + d.y + ',' + d.x + ')';
};
var verticalTransform = function verticalTransform(d) {
    return 'translate(' + d.x + ',' + d.y + ')';
};

var horizontalLabelTextAnchor = function horizontalLabelTextAnchor(d) {
    return d.children ? 'end' : 'start';
};
var horizontalReverseLabelTextAnchor = function horizontalReverseLabelTextAnchor(d) {
    return d.children ? 'start' : 'end';
};
var verticalLabelTextAnchor = 'middle';

var labelPositions = {
    root: {
        'horizontal': _labels.LABEL_POSITION_LEFT,
        'horizontal-reverse': _labels.LABEL_POSITION_RIGHT,
        'vertical': _labels.LABEL_POSITION_TOP,
        'vertical-reverse': _labels.LABEL_POSITION_BOTTOM
    },
    intermediate: {
        'horizontal': _labels.LABEL_POSITION_LEFT,
        'horizontal-reverse': _labels.LABEL_POSITION_RIGHT,
        'vertical': _labels.LABEL_POSITION_TOP,
        'vertical-reverse': _labels.LABEL_POSITION_BOTTOM
    },
    leaf: {
        'horizontal': _labels.LABEL_POSITION_RIGHT,
        'horizontal-reverse': _labels.LABEL_POSITION_LEFT,
        'vertical': _labels.LABEL_POSITION_LEFT,
        'vertical-reverse': _labels.LABEL_POSITION_RIGHT
    }
};

var computeLabelPositions = function computeLabelPositions(_ref) {
    var direction = _ref.direction,
        rootLabelPosition = _ref.rootLabelPosition,
        intermediateLabelPosition = _ref.intermediateLabelPosition,
        leafLabelPosition = _ref.leafLabelPosition;

    rootLabelPosition = rootLabelPosition || labelPositions.root[direction];
    intermediateLabelPosition = intermediateLabelPosition || labelPositions.intermediate[direction];
    leafLabelPosition = leafLabelPosition || labelPositions.leaf[direction];

    return {
        rootLabelPosition: rootLabelPosition,
        intermediateLabelPosition: intermediateLabelPosition,
        leafLabelPosition: leafLabelPosition
    };
};

var labelRotations = {
    root: {
        'horizontal': 0,
        'horizontal-reverse': 0,
        'vertical': 0,
        'vertical-reverse': 0
    },
    intermediate: {
        'horizontal': 0,
        'horizontal-reverse': 0,
        'vertical': 0,
        'vertical-reverse': 0
    },
    leaf: {
        'horizontal': 0,
        'horizontal-reverse': 0,
        'vertical': -90,
        'vertical-reverse': -90
    }
};

var computeLabelRotations = function computeLabelRotations(_ref2) {
    var direction = _ref2.direction,
        rootLabelRotation = _ref2.rootLabelRotation,
        intermediateLabelRotation = _ref2.intermediateLabelRotation,
        leafLabelRotation = _ref2.leafLabelRotation;

    rootLabelRotation = rootLabelRotation || labelRotations.root[direction];
    intermediateLabelRotation = intermediateLabelRotation || labelRotations.intermediate[direction];
    leafLabelRotation = leafLabelRotation || labelRotations.leaf[direction];

    return {
        rootLabelRotation: rootLabelRotation,
        intermediateLabelRotation: intermediateLabelRotation,
        leafLabelRotation: leafLabelRotation
    };
};

var Tree = function (_Component) {
    _inherits(Tree, _Component);

    function Tree() {
        _classCallCheck(this, Tree);

        return _possibleConstructorReturn(this, (Tree.__proto__ || Object.getPrototypeOf(Tree)).apply(this, arguments));
    }

    _createClass(Tree, [{
        key: 'renderD3',
        value: function renderD3(nextProps) {
            var root = nextProps.root,
                identity = nextProps.identity,
                labelFn = nextProps.labelFn,
                containerWidth = nextProps.containerWidth,
                containerHeight = nextProps.containerHeight,
                direction = nextProps.direction,
                colors = nextProps.colors,
                nodeRadius = nextProps.nodeRadius,
                transitionDuration = nextProps.transitionDuration,
                transitionEasing = nextProps.transitionEasing,
                labelOffset = nextProps.labelOffset,
                labelPaddingX = nextProps.labelPaddingX,
                labelPaddingY = nextProps.labelPaddingY;


            var margin = _lodash2.default.assign({}, _Nivo2.default.defaults.margin, this.props.margin);

            var width = containerWidth - margin.left - margin.right;
            var height = containerHeight - margin.top - margin.bottom;

            var element = _d2.default.select((0, _reactDom.findDOMNode)(this)).attr({
                width: containerWidth,
                height: containerHeight
            });

            var position = void 0;
            var size = void 0;
            var diagonal = void 0;
            var transformer = void 0;
            var labelTextAnchor = void 0;

            switch (direction) {
                case 'horizontal':
                    position = [margin.left, margin.top];
                    size = [height, width];
                    diagonal = horizontalDiagonal;
                    transformer = horizontalTransform;
                    labelTextAnchor = horizontalLabelTextAnchor;
                    break;

                case 'horizontal-reverse':
                    position = [margin.left + width, margin.top];
                    size = [height, -width];
                    diagonal = horizontalDiagonal;
                    transformer = horizontalTransform;
                    labelTextAnchor = horizontalReverseLabelTextAnchor;
                    break;

                case 'vertical':
                    position = [margin.left, margin.top];
                    size = [width, height];
                    diagonal = verticalDiagonal;
                    transformer = verticalTransform;
                    labelTextAnchor = verticalLabelTextAnchor;
                    break;

                case 'vertical-reverse':
                    position = [margin.left, margin.top + height];
                    size = [width, -height];
                    diagonal = verticalDiagonal;
                    transformer = verticalTransform;
                    labelTextAnchor = verticalLabelTextAnchor;
                    break;
            }

            var wrapper = element.select('.nivo_tree_wrapper').attr({ width: width, height: height });
            var previousNodes = _lodash2.default.cloneDeep(wrapper.selectAll('.nivo_tree_circle').data());

            wrapper
            //.transition()
            //.duration(transitionDuration)
            //.ease(transitionEasing)
            .attr('transform', 'translate(' + position[0] + ',' + position[1] + ')');

            var cluster = _d2.default.layout.cluster().size(size);

            var color = (0, _ColorUtils.getColorRange)(colors);

            // prevents mutation on the original object by cloning original dataset
            // add color to each datum
            var nodes = cluster.nodes(_lodash2.default.cloneDeep(root)).map(function (node) {
                node.hierarchicalType = (0, _HierarchyUtils.getHierarchicalNodeType)(node);
                if (node.depth <= 1) {
                    node.color = color(node.name);
                } else if (node.depth > 1) {
                    node.color = node.parent.color;
                }

                return node;
            });

            var links = cluster.links(nodes);

            // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
            // Links
            // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
            var link = wrapper.selectAll('.nivo_tree_link').data(links, function (d) {
                return identity(d.source) + '.' + identity(d.target);
            });

            link.enter().append('path').attr('fill', 'none').style('stroke', function (d) {
                return d.target.color;
            }).attr('class', 'nivo_tree_link').attr('d', diagonal).attr('stroke-dasharray', function () {
                return this.getTotalLength();
            }).attr('stroke-dashoffset', function () {
                return this.getTotalLength();
            });

            link.transition()
            //.delay(d => d.source.depth * transitionDuration)
            .duration(transitionDuration).ease(transitionEasing).attr('d', diagonal).attr('stroke-dasharray', function () {
                return this.getTotalLength();
            }).attr('stroke-dashoffset', 0);

            link.exit().transition().duration(transitionDuration).ease(transitionEasing).attr('stroke-dashoffset', function () {
                return this.getTotalLength();
            }).remove();

            // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
            // Circles
            // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
            var circle = wrapper.selectAll('.nivo_tree_circle').data(nodes, identity);

            circle.enter().append('circle').attr('class', 'nivo_tree_circle').style('fill', function (d) {
                return d.color;
            }).attr('transform', transformer).attr('r', 0);

            circle.transition()
            //.delay(d => d.depth * transitionDuration)
            .duration(transitionDuration).ease(transitionEasing).attr('transform', transformer).attr('r', nodeRadius);

            circle.exit().remove();

            // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
            // Labels
            // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
            var label = wrapper.selectAll('.nivo_tree_label').data(nodes, identity);

            var _computeLabelPosition = computeLabelPositions(nextProps),
                rootLabelPosition = _computeLabelPosition.rootLabelPosition,
                intermediateLabelPosition = _computeLabelPosition.intermediateLabelPosition,
                leafLabelPosition = _computeLabelPosition.leafLabelPosition;

            var _computeLabelRotation = computeLabelRotations(nextProps),
                rootLabelRotation = _computeLabelRotation.rootLabelRotation,
                intermediateLabelRotation = _computeLabelRotation.intermediateLabelRotation,
                leafLabelRotation = _computeLabelRotation.leafLabelRotation;

            label.enter().append('g').attr('class', 'nivo_tree_label').style('opacity', 0).each(function (d) {
                var el = _d2.default.select(this);

                var position = void 0;
                var rotation = void 0;
                if (d.hierarchicalType === _HierarchyUtils.HIERARCHICAL_NODE_TYPE_ROOT) {
                    position = rootLabelPosition;
                    rotation = rootLabelRotation;
                } else if (d.hierarchicalType === _HierarchyUtils.HIERARCHICAL_NODE_TYPE_LEAF) {
                    position = leafLabelPosition;
                    rotation = leafLabelRotation;
                } else {
                    position = intermediateLabelPosition;
                    rotation = intermediateLabelRotation;
                }

                el.attr('transform', transformer(d) + ' rotate(' + rotation + ')');

                el.call((0, _labels2.default)({
                    text: d.name,
                    position: position,
                    labelOffset: 0,
                    labelPaddingX: labelPaddingX,
                    labelPaddingY: labelPaddingY
                }));
            });

            label.transition()
            //.delay(d => d.depth === 0 ? 0 : (Math.max(d.depth - 1, 0) + 1) * transitionDuration)
            .duration(transitionDuration).ease(transitionEasing).style('opacity', 1).attr('transform', function (d) {
                var translate = transformer(d);

                var rotation = void 0;
                if (d.hierarchicalType === _HierarchyUtils.HIERARCHICAL_NODE_TYPE_ROOT) {
                    rotation = rootLabelRotation;
                } else if (d.hierarchicalType === _HierarchyUtils.HIERARCHICAL_NODE_TYPE_LEAF) {
                    rotation = leafLabelRotation;
                } else {
                    rotation = intermediateLabelRotation;
                }

                return translate + ' rotate(' + rotation + ')';
            }).each(function (d) {
                var el = _d2.default.select(this);

                var position = void 0;
                if (d.hierarchicalType === _HierarchyUtils.HIERARCHICAL_NODE_TYPE_ROOT) {
                    position = rootLabelPosition;
                } else if (d.hierarchicalType === _HierarchyUtils.HIERARCHICAL_NODE_TYPE_LEAF) {
                    position = leafLabelPosition;
                } else {
                    position = intermediateLabelPosition;
                }

                el.call((0, _labels2.default)({
                    text: d.name,
                    position: position,
                    labelOffset: labelOffset,
                    labelPaddingX: labelPaddingX,
                    labelPaddingY: labelPaddingY
                }));
            });
        }
    }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps) {
            this.renderD3(nextProps);

            return false;
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.renderD3(this.props);
        }
    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(
                'svg',
                { className: 'nivo_tree' },
                _react2.default.createElement('g', { className: 'nivo_tree_wrapper' })
            );
        }
    }]);

    return Tree;
}(_react.Component);

var object = _react.PropTypes.object,
    number = _react.PropTypes.number,
    string = _react.PropTypes.string,
    func = _react.PropTypes.func,
    any = _react.PropTypes.any,
    oneOf = _react.PropTypes.oneOf;


Tree.propTypes = {
    containerWidth: number.isRequired,
    containerHeight: number.isRequired,
    margin: _PropTypes.margin,
    root: object.isRequired,
    identity: func.isRequired,
    labelFn: func.isRequired,
    direction: oneOf(['horizontal', 'horizontal-reverse', 'vertical', 'vertical-reverse']).isRequired,
    colors: any.isRequired,
    nodeRadius: number.isRequired,
    transitionDuration: number.isRequired,
    transitionEasing: string.isRequired,
    labelOffset: number.isRequired,
    labelPaddingX: number.isRequired,
    labelPaddingY: number.isRequired,
    rootLabelPosition: string,
    intermediateLabelPosition: string,
    leafLabelPosition: string,
    rootLabelRotation: number,
    intermediateLabelRotation: number,
    leafLabelRotation: number
};

Tree.defaultProps = {
    margin: _Nivo2.default.defaults.margin,
    labelFn: function labelFn(d) {
        return d.name;
    },
    direction: 'horizontal',
    identity: function identity(d) {
        return (d.parent ? d.parent.name : 'root') + '.' + d.name + '.' + d.depth;
    },
    colors: _Nivo2.default.defaults.colorRange,
    labelOffset: 8,
    labelPaddingX: 8,
    labelPaddingY: 4,
    nodeRadius: 6,
    transitionDuration: _Nivo2.default.defaults.transitionDuration,
    transitionEasing: _Nivo2.default.defaults.transitionEasing
};

exports.default = (0, _reactDimensions2.default)()(Tree);