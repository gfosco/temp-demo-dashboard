/*
 * This file is part of the nivo project.
 *
 * (c) RaphaÃ«l Benitte
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.tilingMethods = undefined;

var _d3Hierarchy = require('d3-hierarchy');

var tilingMethods = exports.tilingMethods = {
    binary: _d3Hierarchy.treemapBinary,
    dice: _d3Hierarchy.treemapDice,
    slice: _d3Hierarchy.treemapSlice,
    sliceDice: _d3Hierarchy.treemapSliceDice,
    squarify: _d3Hierarchy.treemapSquarify,
    resquarify: _d3Hierarchy.treemapResquarify
};

/**
 * This wrapper is responsible for computing treemap chart positions.
 * It's used for all TreeMap related chart components.
 *
 * @returns {{ compute: (function) }}
 * @constructor
 */
var TreeMapHelper = function TreeMapHelper() {
    var treemap = (0, _d3Hierarchy.treemap)();

    return {
        /**
         *
         * @param {number}   width
         * @param {number}   height
         * @param {object}   _root
         * @param {boolean}  leavesOnly
         * @param {string}   tile
         * @param {number}   innerPadding
         * @param {number}   outerPadding
         * @param {function} identity
         * @param {function} value
         * @param {function} color
         */
        compute: function compute(_ref) {
            var width = _ref.width,
                height = _ref.height,
                _root = _ref.root,
                leavesOnly = _ref.leavesOnly,
                tile = _ref.tile,
                innerPadding = _ref.innerPadding,
                outerPadding = _ref.outerPadding,
                identity = _ref.identity,
                value = _ref.value,
                color = _ref.color;

            treemap.size([width, height]).tile(tilingMethods[tile]).round(true).paddingInner(innerPadding).paddingOuter(outerPadding);

            var root = treemap((0, _d3Hierarchy.hierarchy)(_root).sum(value));

            var nodes = leavesOnly ? root.leaves() : root.descendants();

            return nodes.map(function (d) {
                d.color = color(d.depth);
                /*
                 if (d.depth > 1) {
                 d.color = color(d.parentId)
                 } else {
                 d.color = color(identity(d.data))
                 }
                 */

                d.data.key = d.ancestors().map(function (a) {
                    return identity(a.data);
                }).join('.');

                return d;
            });
        }
    };
};

exports.default = TreeMapHelper;